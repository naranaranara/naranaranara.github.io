---
layout: post
title:  "Cook's Plane Strain Problem"
toc: true          # 우측 목차
toc_sticky: true   # 스크롤해도 고정
date: 2025-11-11
tags: [fem, blog]
use_math: true
mathjax: true
---
# Cook's plane strain problem
<img width="153" height="137" alt="image" src="https://github.com/user-attachments/assets/2331e098-2872-4a02-85ed-99ec25285422" />  

1\. 문제: P 점에서 y축 방향 변위를 구해라  
2\. 조건: x=0 (왼쪽 모서리)는 디리클레 경계조건으로 변위가 0 으로 고정하고 x=48 (오른쪽 모서리)에는 F=1N이 작용한다. $K= 8000N/mm^2$이고 $\mu= 0.8N/mm^2$  
3\. 결과: dof 변화에 따른 수직 변화 그래프  
<br>  
일단 문제를 처음 봤을 때는 포아송비부터 구해야겠다고 생각함.  
$ \nu= \frac{3K-2\mu}{6K+2\mu}=0.5$  
$E=2\mu(1+\nu)=2.4 N/mm^2$  
<br>
일단 여기까지 구하고 알 수 있었던 점은 포아송비가 0.5이라는 것은 고무같이 잘 변형되는 재질이라는 점을 알 수 있었다.  
그리고 나서 부딪힌 문제는 모양이 사다리꼴이라는 것이다. 전에는 직사각형이여서 x의 최대 최소, y의 최대 최소 값을 그대로 사용할 수 있었다.  
그래서 사다리꼴이니까 함수꼴로 위아래를 표현할 수 있겠다고 생각했다.  
<br>  

```c++
template <int dim>
void FEM<dim>::generate_mesh(std::vector<unsigned int> numberOfElements)
{
  const double x_min = 0.0;
  const double x_max = Lx;
  const double y_min = 0.0;
  const double y_max = 1;   // 

  Point<dim,double> min(x_min,y_min);
  Point<dim,double> max(x_max,y_max);

  GridGenerator::subdivided_hyper_rectangle(triangulation,
                                            numberOfElements,
                                            min, max);

  auto transform = [](const Point<dim,double> &p)->Point<dim,double>
  {
    Point<dim,double> out;
    const double x = p[0];
    const double y_ref = p[1]; // 0~1

    const double y_bottom = (44/48.0)*x;
    const double y_top    = (16/48.0)*x + 44;

    out[0] = x;
    out[1] = y_bottom + y_ref * (y_top - y_bottom);
    return out;
  };
  GridTools::transform(transform, triangulation);
}
```
코드 흐름대로 생각해보면  
일단 x최소는 0 최대는 Lx, y최소는 0 최대는 1로 둔다. -> 선형 보간에서 사용  
2차원 점 최소는(0,0) 최대는(24,1)점이다. 직사각형을 만든 부분
<br>
사다리꼴 만드는 과정 시작  
auto함수는 원래 값을 받아서 새로운 값을 주는 함수이고 {} 안의 부분이 auto함수가 어떻게 구성되는지 정하는 부분  
x라는 변수를 p[0], 여기서 p[0]은 x축에 있는 값을 하나씩 가져오는 것이다.  
똑같이 y_ref 라는 변수에 p[1], y축에 있는 값을 하나씩 가져오는 것이다.  
그리고 새로운 점 out[]을 돌려준다.  
out[0]=x,새로운 x좌표는 x변수랑 그대로 쓴다. out[1]은 y_ref값은 p[1]이니까 p[1]은 0~1 값 중 한 점이다.  
따라서 p[1]=1이면 y_top이고 p[1]=0이면 y_bottom이 된다. 사다리꼴 윗변 아랫변을 지정해줬다.  
<br>  

여기까지해서 일단 domain 모양은 만들었다. 이제 문제 조건에서 왼쪽은 클램프로 완전 고정인 경계조건을 만든다.  
=0 조건이기 때문에 디리클레 경계조건을 사용하면 된다.  
```c++
template <int dim>
void FEM<dim>::define_boundary_conds()
{
  boundary_values.clear();
  const unsigned int totalDOFs = dof_handler.n_dofs();
  const double tol = 1e-10;

  for (unsigned int g = 0; g < totalDOFs; ++g)
  {
    const double x = dofLocation[g][0];

    if (use_bc1 && std::abs(x - 0.0) < tol)
    {
      boundary_values[g] = 0.0;
    }
  }
}
```

처음에는 clear 한번 해주고  
unsigned int(정수)인 totalDOFs라는 변수 만들어서 dofhandler라는 객체한데 지금 자유도 몇개인지 물어봐서 넣어준다.  
tol은 1e-10으로 지정 -> 완벽하게 0이 아닐 수도 있게 때문에 tol값을 준다.  
for 문은 정수 g=0부터 totlaDOFs 전까지 1씩 증가하면서 {} 안의 함수를 실행  
x 변수를 dofLocation[g][0], g번째 dof의 x좌표로 지정  
<br>  
만약에 x<tol 즉, x=0이면 g번 자유도를 0으로 고정해라.  

마지막 경계조건인 노이만 경계조건 지정해줘야 한다.  
```
    if (use_traction_right)
    {
      Vector<double> h(dim);
      h = 0.;

      for (unsigned int f=0; f < faces_per_elem; ++f)
      {
        fe_face_values.reinit (elem, f);

        if (std::abs(elem->face(f)->center()[0] - Lx) < 1e-10)
        {
          for (unsigned int q=0; q<num_face_quad_pts; ++q)
          {
            h[0] = 0.0;
            h[1] = traction_ty; 

            for (unsigned int A=0; A<nodes_per_elem; ++A)
            {
              for(unsigned int i=0; i<dim; ++i)
              {
                const unsigned int a  = dim*A + i;
                const double Ni = fe_face_values.shape_value(a,q);

                Flocal[a] += Ni * h[i] * fe_face_values.JxW(q);
              }
            }
          }
        }
      }
    }
```

벡터를 h로 지정하고 0으로 초기화  
f가 faces_per_elem까지 1씩 더하면서 {}를 수행  
fe_face_value는 Jxw, shape fuction 값들을 알고있음. reint는 elem의 f로 계산  
<br>  
if문 안에서 elem의 f번째 면의 센터의 x좌표가 Lx면  
정수 qfmf num_face_quad_pts까지 1씩 증가시키면서 {} 수행  
h벡터의 x좌표가 0이고, y좌표가 traction_ty  
여기까지 과정이 F를 오른쪽 모서리에 부여한 것임  
<br>  
이제 조립하는 과정  
A를 nodes_per_elem까지 1씩 증가시키면서 {} 수행  
정수 i가 dim(2)보다 작을때까지 1씩 증가시키면서 {} 수행  
<br>
여기서 a를 지정해주는 이유는 현재는 (x,y)좌표로 묶여있는 부분을 1차원으로 풀기 위해서 풀어써야하기 때문이다.  
| A(노드) | i(성분) | a = 2*A + i | 의미         |
|--------|---------|------------|--------------|
| 0      | 0       | 0          | 노드0의 u_x  |
| 0      | 1       | 1          | 노드0의 u_y  |
| 1      | 0       | 2          | 노드1의 u_x  |
| 1      | 1       | 3          | 노드1의 u_y  |
| 2      | 0       | 4          | 노드2의 u_x  |
| 2      | 1       | 5          | 노드2의 u_y  |
| 3      | 0       | 6          | 노드3의 u_x  |
| 3      | 1       | 7          | 노드3의 u_y  |

그 후에는 $F_{a,i} = \int_{\Gamma_N} N_a h_i d\Gamma$ 노이만항을 계산해서 Flocal의 [a]번째 자리에 넣어줌.  





