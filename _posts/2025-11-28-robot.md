---
layout: post
title:  "Robot"
toc: true          # 우측 목차
toc_sticky: true   # 스크롤해도 고정
date: 2025-11-28
tags: [markdown, blog]
use_math: true
mathjax: true
---
## 2R1P 글씨 쓰는 로봇 만들기

**개요**: 2개의 회전 관절(2R)과 1개의 리프팅 관절(1P)을 가진 로봇을 제작하여 특정 궤적을 그리는 시스템 구현  

<img width="709" height="407" alt="image" src="https://github.com/user-attachments/assets/e3ff855b-20ff-4499-bc97-2bf2dbf4b376" />  

<img width="1172" height="845" alt="image" src="https://github.com/user-attachments/assets/c03b7b75-8e8b-4e9e-a136-db401d34db62" />  

**회로도**  

<img width="494" height="325" alt="image" src="https://github.com/user-attachments/assets/6fbf3d1e-487e-49d0-b0c6-56ed68de2f32" />  

1\. 스텝모터 드라이버 1  
EN-: 5번  
DIR-: 6번  
PUL-: 7번  

2\. 스텝모터 드라이버 2  
EN-: 10번  
DIR-: 11번  
PUL-: 12번  

3\. 서보모터 : 3번  

**좌표설정**  

<img width="284" height="275" alt="image" src="https://github.com/user-attachments/assets/0fef386d-332c-4967-a939-56ba78b8f8f3" />  

1\. r, theta 좌표계 그대로 사용  
2\. y축 양의 방향을 x축 양의 방향으로 보고 반시계 방향을 양, 시계 방향을 음으로 설정  
3\. 원점을 새로 설정한 x축 방향으로 100 뒤로 옮김 $\rightarrow$ 그대로 사용했을 때 로봇의 베이스에 글자가 걸려서  

**모터 각도 구하기**  

1\. case 분류  

좌표계를 보았을 때, r이 일정한 경우와 theta가 일정한 경우, r과 theta 모두 변하는 경우로 나눌 수 있었다.  

```matlab
switch lower(path_mode)
    case 'consttheta'
        if abs(theta1_old - theta0_old) > deg2rad(0.1)
            warning('constTheta 모드인데 theta0_old ~= theta1_old 입니다. theta0_old를 기준으로 사용합니다.');
        end
        theta_path_old = theta0_old * ones(1, N);      % [rad]
        r_path_old_mm  = linspace(r0_old_mm, r1_old_mm, N);  % [mm]

    case 'constr'
        if abs(r1_old_mm - r0_old_mm) > 1e-4
            warning('constR 모드인데 r0_old ~= r1_old 입니다. r0_old를 기준으로 사용합니다.');
        end
        r_path_old_mm  = r0_old_mm * ones(1, N);       % [mm]
        theta_path_old = linspace(theta0_old, theta1_old, N);  % [rad]
    case 'general'
        r_path_old_mm  = linspace(r0_old_mm,  r1_old_mm,  N); % [mm]
        theta_path_old = linspace(theta0_old, theta1_old, N); % [rad]

    otherwise
        error('path_mode는 ''constTheta'' 또는 ''constR'' 이어야 합니다.');
end
```

2.\ 도달 가능 범위 체크  

로봇 암을 다 폈을 때보다 목표 지점이 멀면 도달이 불가하고 로봇 팔을 다 접었을 때보다 가까우면 도달할 수 없다.  

```matlab
    % 도달 가능 범위 체크: |L1-L2| <= r <= L1+L2
    r_min = abs(L1 - L2);
    r_max = L1 + L2;
    if r < r_min || r > r_max
        warning('k=%d: r=%.3f m (reachable range %.3f~%.3f 밖)', ...
                 k, r, r_min, r_max);
```

3.\ 관절 각도 구하기  

<img width="1037" height="749" alt="image" src="https://github.com/user-attachments/assets/eb6486a2-9fc0-4869-b4a9-02d069e8fd7c" />  

```matlab
    r_min = abs(L1 - L2);
    r_max = L1 + L2;
    if r < r_min || r > r_max
        warning('k=%d: r=%.3f m (reachable range %.3f~%.3f 밖)', ...
                 k, r, r_min, r_max);
    end

    % 코사인 법칙으로 q2
    c2 = (r^2 - L1^2 - L2^2) / (2*L1*L2);
    c2 = max(min(c2, 1), -1);  % 수치 에러 보정

    switch lower(elbow)
        case 'up'
            s2 =  sqrt(1 - c2^2);
        case 'down'
            s2 = -sqrt(1 - c2^2);
        otherwise
            error('elbow는 ''up'' 또는 ''down'' 이어야 합니다.');
    end

    q2 = atan2(s2, c2);

    % q1 = 목표점 방향각 - 팔 꺾임각
    phi = atan2(y, x);                 % O' -> (x,y) 방향각
    psi = atan2(L2*s2, L1 + L2*c2);    % 팔 구부러진 각도
    q1  = phi - psi;

    q1_path(k) = q1;   % [rad]
    q2_path(k) = q2;   % [rad]
end
```










