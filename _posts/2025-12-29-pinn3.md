---
layout: post
title:  "PINN - Hertzian contact problem"
toc: true          # 우측 목차
toc_sticky: true   # 스크롤해도 고정
date: 2025-12-29
tags: [markdown, blog]
use_math: true
mathjax: true
---
## Hertzian contact problem  

<img width="613" height="224" alt="image" src="https://github.com/user-attachments/assets/8fd1e4f3-95d3-406e-b9a0-5095780a83f3" />  

1\. 물리 세팅  

- 물체: half-clinder (반원기둥)
  - 재료: 선형탄성체
  - 재료 상수: $E=200, \nu =0.3$
  - 반지름: $R=1$
  - 2D 문제
    
- 바닥: rigid flat surface
  - 변형 안 함 (완전 딱딱)
  - 변형을 전부 반원기둥 쪽에서만 생긴다
    
- 하중: 반원기둥 윗면에 균일 압력 $p=0.5$를 아래로 가함

2\. 접촉압 해석해  

$$
p_{c} = \frac{4Rp}{\pi b^{2}} \sqrt{b^{2} - x^{2}} \quad \text{with} \quad b = 2\sqrt{\frac{2R^{2}p(1 - \nu^{2})}{E\pi}}.
$$  

- 주어진 값: $p=0.5, E=200, \nu= 0.3, R=1$을 넣으면 $b=0.076$

3\. data  

접촉압 $p_c$는 해석해가 있지만, 반원기둥 내부의 변위/응력장은 해석해가 제한적이라서 FEM으로 reference solution을 만든다.  

## 코드 정리  

저번 네모(사각형) 케이스는 구조물이 가장 안정적인 변형 상태를 찾는 문제로 **에너지 최소화**(Deep Energy)로 풀었다.  
지금은 Hertzian 케이스로 PDE(평형방정식 + 구성방정식)을 만족하는 해를 찾는 문제로 **잔차 최소화 + 접촉(KKT)**을 BC로 강제한다.  

- 에너지 최소화
  $$
  \Pi(u) = \int_{\Omega} W(\varepsilon(u)) \, d\Omega - \int_{\Gamma_{t}} \mathbf{t} \cdot \mathbf{u} \, d\Gamma + (\text{접촉 제약 패널티/항들})
  $$

- 잔차 최소화
  $$
  \mathcal{L} = \underbrace{\| \nabla \cdot \sigma \|^2}_{\text{평형}} + \underbrace{\| \sigma - C : \varepsilon(u) \|^2}_{\text{구성/연결}} + \underbrace{(\text{BC 잔차})}_{\text{Neumann/Contact}} + \underbrace{(\text{FEM 관측 오차})}_{\text{PointSetBC}}
  $$

1\. 물체가 바닥에서 얼마나 떨어져 있는지  

```python
def calculate_gap_in_normal_direction(x,y,X):
   
    gap_y = x[:,1:2] + y[:,1:2] + radius + distance

    normals, cond = calculate_boundary_normals(X,geom)

    gap_n = bkd.math.divide_no_nan(gap_y[cond],bkd.math.abs(normals[:,1:2]))
    
    return gap_n
```

바닥의 위치를 $y= - (R+distance)$, 어떤 점의 변형 후 y 좌쵸는 $y+u_y$이다.  
따라서 y 방향으로 거리는 gap_y 처럼 표현된다.  

gap_y는 위아래(수직) 방향으로의 차이이고, gap_n은 표면 법선 방향으로 차이이다.  
gap_n은 gap_y에 normal_y 의 크기로 나눠서 구한다. 왜냐하면 gap_y는 gap_n에 normal_y의 곱으로 표현되기 때문이다.  

2\. BCs- 경계조건  

```python
def boundary_circle_not_contact(x, on_boundary):
    return on_boundary and np.isclose(np.linalg.norm(x - center, axis=-1), radius) and (x[0]<x_loc_partition)

def boundary_circle_contact(x, on_boundary):
    return on_boundary and np.isclose(np.linalg.norm(x - center, axis=-1), radius) and (x[0]>=x_loc_partition)

bc_zero_traction_x = dde.OperatorBC(geom, zero_neumann_x, boundary_circle_not_contact)
bc_zero_traction_y = dde.OperatorBC(geom, zero_neumann_y, boundary_circle_not_contact)

bc_zero_fischer_burmeister = dde.OperatorBC(geom, zero_fischer_burmeister, boundary_circle_contact)
bc_zero_tangential_traction = dde.OperatorBC(geom, zero_tangential_traction, boundary_circle_contact)
```

- dde.OperateBC(geom, func, boundary)
  - boundary가 True인 점들만 골라서
  - 그 점들에서 func(x,y,X)를 계산하고
  - 그 결과가 0 이 되도록 loss를 만든다.

3\. BCs- 데이터 조건(FEM 결과값)  

```python
if add_external_data:
    fem_path = str(Path(__file__).parent.parent.parent)+"/Hertzian_fem/Hertzian_fem_fine_mesh.csv"
    df = pd.read_csv(fem_path)
    fem_results = df[["Points_0","Points_1","displacement_0","displacement_1","nodal_cauchy_stresses_xyz_0","nodal_cauchy_stresses_xyz_1","nodal_cauchy_stresses_xyz_3"]]
    fem_results = fem_results.to_numpy()

    node_coords_xy = fem_results[:,0:2]
    displacement_fem = fem_results[:,2:4]
    stress_fem = fem_results[:,4:7]

    on_radius = np.isclose(np.linalg.norm(node_coords_xy - center, axis=-1), radius)
    on_right = np.isclose(node_coords_xy[:,0], center[0])
    on_top = np.isclose(node_coords_xy[:,1], center[1])
    on_boundary_ = np.logical_or(np.logical_or(on_radius,on_right),on_top)

    n_boundary = 100
    n_domain = 100

    observe_u = dde.PointSetBC(ex_data_xy, ex_data_disp[:,0:1], component=0)
    observe_v = dde.PointSetBC(ex_data_xy, ex_data_disp[:,1:2], component=1)
    observe_sigma_xx = dde.PointSetBC(ex_data_xy, ex_data_stress[:,0:1], component=2)
    observe_sigma_yy = dde.PointSetBC(ex_data_xy, ex_data_stress[:,1:2], component=3)
    observe_sigma_xy = dde.PointSetBC(ex_data_xy, ex_data_stress[:,2:3], component=4)
    
    bcs_data = [observe_u, observe_v, observe_sigma_xx, observe_sigma_yy, observe_sigma_xy]
    
    bcs.extend(bcs_data)


n_dummy = 1
data = dde.data.PDE(
    geom,
    pde_mixed_plane_strain,
    bcs,
    num_domain=n_dummy,
    num_boundary=n_dummy,
    num_test=None,
    train_distribution = "Sobol",
    anchors=(ex_data_xy if add_external_data else None)
)
```

FEM 결과 값을 load해서 PointSetBC로 이 점들에서는 u,v,$\sigma$xx,$\sigma$yy,$\sigma$xy 가 FEM 값과 비슷해지게 손실항 추가  

## 결과  

<img width="659.5" height="362" alt="image" src="https://github.com/user-attachments/assets/e3efdfc0-d790-4949-91d8-51518ae16bf9" />  

위가 PINN으로 예측한 값, 아래가 FEM 결과값  

<img width="387.5" height="308.5" alt="image" src="https://github.com/user-attachments/assets/10948fec-b4f2-4b07-b2d8-3f94962c9e4c" />  

위의 그래프로 PINN이 접촉경계에서의 압력 분포를 Hertzian 해랑 얼마나 비슷하게 맞추는지 볼 수 있다.  

1\. 접촉 영역을 이론으로 계산한 b 값 (0.076)과 잘 맞는다.  
2\. 중심 압력(최대값)은 해석해가 더 높고 예측해가 더 낮아보인다. 이를 통해서 최대 압력을 과소 예측하는 경향을 파악할 수 있다.  
3\. 접촉 끝에서 PINN은 0으로 딱 떨어지지 않고 끝부분 오차가 커진다. edge 근처는 압력이 0 으로 떨어지면서 기울기가 급격하게 커지고, 접촉/비접촉 상태가 바뀌는 KKT 조건을 만족해야 해서 오차가 생기기 쉽다.  
















  
